<html><head><title>JSAN</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.01,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008006 at Tue Jul 26 06:58:25 2005 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>JSAN - JavaScript Archive Network</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre lang='und' xml:lang='und'>  &#60;script type=&#34;text/javascript&#34; src=&#34;/js/JSAN.js&#34;&#62;&#60;/script&#62;
  &#60;script&#62;
      JSAN.use(&#39;Test.Simple&#39;);
      plan({tests: 1});
      ok(1 == 1, &#39;one does equal one!&#39;);
  &#60;/script&#62;

  // Or in a library.
  if (typeof JSAN != &#39;undefined&#39;) {
      JSAN.use(&#39;Some.Library&#39;);
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This library allows JavaScript to behave more like traditional programming languages and offers the programmer the abilility to create well-designed, modular code.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_Properties"
>Class Properties</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="globalScope"
>globalScope</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.globalScope = _player;</pre>

<p>By default <code lang='und' xml:lang='und'>globalScope</code> is set to the value of <code lang='und' xml:lang='und'>self</code>. This works great in web browswers, however other environments may not have <code lang='und' xml:lang='und'>self</code> (an alias for <code lang='und' xml:lang='und'>window</code> in web browswers) for a global context. In those cases, such as embedded JavaScript, you should reset <code lang='und' xml:lang='und'>globalScope</code> before calling <code lang='und' xml:lang='und'>use()</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="includePath"
>includePath</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.includePath = [];</pre>

<p>The <code lang='und' xml:lang='und'>includePath</code> is a list of URLs that should be used as prefixes for libraries when they are <code lang='und' xml:lang='und'>use()</code>d. If you are adding repositories please consider using the <code lang='und' xml:lang='und'>addRepository()</code> method.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="errorLevel"
>errorLevel</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.errorLevel = &#34;die&#34;;</pre>

<p>By default the <code lang='und' xml:lang='und'>errorLevel</code> is set to <i>none</i>. This will supress errors when trying to load libraries.</p>

<p><i>die</i> will throw an exception and it is the responsibility of the calling code to catch it.</p>

<p><i>warn</i> will use the <code lang='und' xml:lang='und'>alarm()</code> function, usually present in web browsers, to alert a user on error. This is good for debugging (in web browsers).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="errorMessage"
>errorMessage</a></h3>

<pre lang='und' xml:lang='und'>  var error = JSAN.errorMessage;</pre>

<p>This contains the text of any error, no matter what the <code lang='und' xml:lang='und'>errorLevel</code>. Inspect it to discover problems.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loaded"
>loaded</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.loaded[&#34;Foo/Bar.js&#34;] = Foo.Bar;</pre>

<p>This object lists path to class definition mappings. The object is populated with members by <code lang='und' xml:lang='und'>JSAN.require()</code>. The class definition is the one found when evaluating the package name during namespace creation. It is the same class definition that <code lang='und' xml:lang='und'>JSAN.require()</code> and <code lang='und' xml:lang='und'>JSAN.use()</code> returns.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_Methods"
>Class Methods</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="JSAN.use()"
>JSAN.use()</a></h3>

<pre lang='und' xml:lang='und'>    JSAN.use(&#39;Test.Simple&#39;);
    JSAN.use(&#39;DOM.Display&#39;);</pre>

<p>Download and import a library. There is a mapping that is done with the library name: it must be converted into a URL. Here is how it works.</p>

<pre lang='und' xml:lang='und'>  Test.Simple        Test/Simple.js
  HTTP.Request       HTTP/Request.js
  Foo.Bar.Baz        Foo/Bar/Baz.js</pre>

<p>Each <code lang='und' xml:lang='und'>includePath</code> is then prepended, and the file requested, until it is found. The first working path in <code lang='und' xml:lang='und'>includePath</code> is used.</p>

<p>The library&#39;s constructor and prototype are imported into the calling context. You can also request certain functions, or groups of functions, to be imported explicitly. These groups can be done either singly or in an array, whichever is more convenient. You can also explicitly choose to import nothing. Here is an example of each.</p>

<pre lang='und' xml:lang='und'>  // Explicitly choose certain functions
  JSAN.use(&#39;Test.More&#39;, &#39;plan&#39;, &#39;ok&#39;, &#39;is&#39;);
  
  // Explicitly choose a certain tag
  JSAN.use(&#39;Digest.MD5&#39;, &#39;:all&#39;);

  // Explicitly choose nothing
  JSAN.use(&#39;Digest.MD5&#39;, []);

  // Be really weird
  var stuff = [ &#39;h&#39;, &#39;i&#39;, [&#39;j&#39;] ];
  stuff.push( &#39;abc&#39; );
  JSAN.use(&#39;Some.Module&#39;, &#39;a&#39;, &#39;b&#39;, [ &#39;c&#39;, &#39;d&#39; ], stuff, &#39;f&#39; );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="JSAN.require()"
>JSAN.require()</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.require(&#39;Some.Class&#39;);</pre>

<p>Loads a class into your scope. This will not export any symbols.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="JSAN.exporter()"
>JSAN.exporter()</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.exporter(Test.More, &#39;plan&#39;, &#39;is&#39;, &#39;cmpOk&#39;);</pre>

<p>Export symbols from the class defined in the first argument to the global scope. Note that the first argument to <code lang='und' xml:lang='und'>JSAN.exporter()</code> is <b>not</b> a string, but the actual class definition. The example above will export the functions <code lang='und' xml:lang='und'>plan</code>, <code lang='und' xml:lang='und'>is</code>, and <code lang='und' xml:lang='und'>cmpOk</code> from the <code lang='und' xml:lang='und'>Test.More</code> namespace to yours.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="JSAN.addRepository()"
>JSAN.addRepository()</a></h3>

<pre lang='und' xml:lang='und'>  JSAN.addRepository(&#39;js/private&#39;);</pre>

<p>Add any number of paths to <code lang='und' xml:lang='und'>includePath</code>. This will move the repository to the beginning of the list and it will be checked first for libraries. Calling <code lang='und' xml:lang='und'>addRepository()</code> will add your include path for the entirety of the request, no matter how many times you call <code lang='und' xml:lang='und'>JSAN.use()</code>.</p>

<p>As with use(), it will accept any combination of arrays and strings.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Compile_Time"
>Compile Time</a></h2>

<p><code lang='und' xml:lang='und'>JSAN</code> creates an interesting sort of compile time for libraries loaded through it. This means that code that does not exist inside of a function is considered <i>compile time</i> code. This has certain implications when a library uses JSAN to import another library.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Namespaces"
>Namespaces</a></h2>

<p>JavaScript - exempting version 2 anyway - does not have a notion of namespaces. For this reason something very important has been missing. However, JavaScript&#39;s object system is perfectly suited to create namespaces for well written code.</p>

<p>The first thing you have to do when creating a library is define the namespace. The namespace must match the library name as well so <code lang='und' xml:lang='und'>use()</code> can import the classes and functions correctly.</p>

<p>The name of this library, <code lang='und' xml:lang='und'>JSAN</code>, or the name of our testing system, <code lang='und' xml:lang='und'>Test.Simple</code>, are examples of namespaces. A namespace is built by defining objects at each level until you reach the final name.</p>

<p>Defining a namespace for JSAN is simple.</p>

<pre lang='und' xml:lang='und'>  var JSAN = {};</pre>

<p>Defining the namespace for <code lang='und' xml:lang='und'>Test.Simple</code> takes a little more work. First you have to create an object at the variable named <code lang='und' xml:lang='und'>Test</code> if it doesn&#39;t already exist. Then you can create an object, or place a constructor, at the <code lang='und' xml:lang='und'>Test.Simple</code> location.</p>

<pre lang='und' xml:lang='und'>  if (Test == undefined) var Test = {};
  Test.Simple = {};</pre>

<p>So far we&#39;ve just been inserting blank objects at the final namespace. That&#39;s fine if your library implements functions and does not implement a class. However, if you implement a class you will want to place a constructor in the final namespace instead.</p>

<pre lang='und' xml:lang='und'>  if (Name == undefined) var Name = {};
  
  Name.Space = function () {
      // This is the constructor.
  }</pre>

<p>Further, you&#39;ll want to define you class. This is done by defining the prototype in your namespace.</p>

<pre lang='und' xml:lang='und'>  Name.Space.prototype = {
      publicProperty: &#39;you see me&#39;,
      
      _privateProperty: &#39;boo&#39;,
      
      publicMethod: function (arg1, arg2) {
          // We do stuff man.
      },
      
      _privateMethod: function () {
          this._privateProperty = &#34;no peaking&#34;;
      }
  };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Exporting"
>Exporting</a></h2>

<p>The <code lang='und' xml:lang='und'>use()</code> function supports an Exporter style system. This means that you can create functions that will be exported to the caller automatically, functions that will be exported when requested, and groups of functions - called tags - that are exported when requested.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h3>

<p>Set up functions that are auto-exported <b>unless</b> the caller declares a function list.</p>

<pre lang='und' xml:lang='und'>  Name.Space.EXPORT = [ &#39;functionOne&#39;, &#39;functionTwo&#39; ];</pre>

<p>Importing the default functions.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;);</pre>

<p>Importing specific functions.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;, &#39;functionOne&#39;); // Don&#39;t want functionTwo()</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT_OK"
>EXPORT_OK</a></h3>

<p>Set up functions that are exported only by request.</p>

<pre lang='und' xml:lang='und'>  Name.Space.EXPORT    = [ &#39;functionOne&#39;, &#39;functionTwo&#39; ];
  Name.Space.EXPORT_OK = [ &#39;specialOne&#39;,  &#39;specialTwo&#39;  ];</pre>

<p>Import the default functions. This will <b>not</b> import any functions inside the <code lang='und' xml:lang='und'>EXPORT_OK</code> list.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;);</pre>

<p>Import some specific function from <code lang='und' xml:lang='und'>EXPORT_OK</code>. This will <b>not</b> import any functions from the <code lang='und' xml:lang='und'>EXPORT</code> list.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;, &#39;specialOne&#39;);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT_TAGS"
>EXPORT_TAGS</a></h3>

<p>Set up a grouping of functions that can be exported all at once. This example also illustrates something I dislike about JavaScript arrays. I&#39;ll leave that for you to discover.</p>

<pre lang='und' xml:lang='und'>  function _expandTheFreakingLists () {
      var expanded = [];
      for (var i = 0; i &#60;= arguments.length; i++ ) {
          var list = arguments[i];
          for (var j = 0; j &#60;= list.length; j++) {
              expanded.push(list[j]);
          }
      }
      return expanded;
  }

  Name.Space.EXPORT_TAGS = {
      &#34;:common&#34;: Name.Space.EXPORT,
      &#34;:all&#34;:    _expandTheFreakingLists(Name.Space.EXPORT, Name.Space.EXPORT_OK)
  };</pre>

<p>Now import all the functions.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;, &#39;:all&#39;);</pre>

<p>Import the common functions and one special one.</p>

<pre lang='und' xml:lang='und'>  jsan.use(&#39;Name.Space&#39;, &#39;:common&#39;, &#39;specialOne&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_Libraries"
>Writing Libraries</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Class_Libraries"
>Class Libraries</a></h3>

<p>Class libraries implement a public class that will be exported to the caller. The public class contains the same name as the package <code lang='und' xml:lang='und'>use()</code> was called with.</p>

<p>First, you have to set up a namespace.</p>

<pre lang='und' xml:lang='und'>  if (DOM == undefined) DOM = {};

  DOM.Display = function () {};</pre>

<p>Next you can define the class&#39;s prototype.</p>

<pre lang='und' xml:lang='und'>  DOM.Display.prototype = {
      register: {},
  
      hideElement: function (id) {
          // Do stuff.
      },
  
      showElement: function (id) {
          // Do stuff.
      },
  
      showOnlyElement: function (id) {
          // Do stuff.
      },
  
      registerElement: function (id) {
          // Do stuff.
      }
  };</pre>

<p>At this point your library may have dependences. If that&#39;s the case you can use <code lang='und' xml:lang='und'>JSAN</code> to try and import them. This works because you have, theoretically, modified the <code lang='und' xml:lang='und'>JSAN.includePath</code> on your initial invocation of the library. So your libraries being <code lang='und' xml:lang='und'>use()</code>d need not know anything about <code lang='und' xml:lang='und'>includePath</code>s.</p>

<pre lang='und' xml:lang='und'>  if (typeof JSAN != &#39;undefined&#39;) {
      JSAN.use(&#39;Some.Dependency&#39;);
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Functional_Libraries"
>Functional Libraries</a></h3>

<p>Functional libraries strictly intend to export a set of functions to the caller. While they may contain a class, or many classes, those classes are not part of the publicly documented API. These are simple to create but a few rules do apply.</p>

<p>First, you still have to set up a namespace.</p>

<pre lang='und' xml:lang='und'>  if (Digest == undefined) var Digest = {};
  Digest.MD5 = {};</pre>

<p>Next you can define your export list.</p>

<pre lang='und' xml:lang='und'>  Digest.MD5.EXPORT_OK   = [  &#39;md5&#39;, &#39;md5Hex&#39;, &#39;md5Base64&#39; ];
  Digest.MD5.EXPORT_TAGS = { &#39;:all&#39;: Digest.MD5.EXPORT_OK };</pre>

<p>Now you may go on to define your functions. They must be fully qualified just like the <code lang='und' xml:lang='und'>EXPORT_OK</code> and <code lang='und' xml:lang='und'>EXPORT_TAGS</code> variables.</p>

<pre lang='und' xml:lang='und'>  Digest.MD5.md5 = function (str) {
      // Do stuff.
  }

  Digest.MD5.md5Hex = function (str) {
      // Do stuff.
  }

  Digest.MD5.md5Base64 = function (str) {
      // Do stuff.
  }</pre>

<p>At this point your library may have dependences. If that&#39;s the case you can use <code lang='und' xml:lang='und'>JSAN</code> to try and import them.</p>

<pre lang='und' xml:lang='und'>  if (typeof JSAN != &#39;undefined&#39;) {
      JSAN.use(&#39;Some.Dependency&#39;);
  } else {
      if (Digest.MD5.DEBUG == true
          &#38;&#38; typeof Some.Dependency == &#39;undefined&#39;) {
          throw new Error(&#34;Some.Dependency not loaded.&#34;);
      }
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>JavaScript Namespaces, <a href="http://justatheory.com/computers/programming/javascript/emulating_namespaces.html" class="podlinkurl"
>http://justatheory.com/computers/programming/javascript/emulating_namespaces.html</a>.</p>

<p>Original JSAN Brainstorming, <a href="http://use.perl.org/~schwern/journal/24112" class="podlinkurl"
>http://use.perl.org/~schwern/journal/24112</a>.</p>

<p>OpenJSAN, <a href="http://openjsan.org" class="podlinkurl"
>http://openjsan.org</a>.</p>

<p>Signed JavaScript, <a href="http://www.mozilla.org/projects/security/components/jssec.html" class="podlinkurl"
>http://www.mozilla.org/projects/security/components/jssec.html</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Casey West, &#60;<em lang='und' xml:lang='und'>casey@geeknest.com</em>&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<pre lang='und' xml:lang='und'>  Copyright (c) 2005 Casey West.  All rights reserved.
  This module is free software; you can redistribute it and/or modify it
  under the terms of the Artistic license.</pre>

<!-- end doc -->

</body></html>
